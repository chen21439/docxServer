需要确认和完善的： 
    docx的顺序性：文本不会跨标题归属
    嵌套表格但没有表格信息

---

# Step-by-Step（高效且可落地）

## Step 0. 读取与准备（单次线性遍历）

* 输入：你当前的“块流”（`blocks[]`，包括 `paragraph` 与 `table`），以及表的 `metadata.header_rows/header_signals`。
* 输出：在内存里维护一个**构建中的章节栈**（stack），以及一个**结果树**（root → children…）。

> 复杂度：O(N)；只遍历一次主序列。

---

## Step 1. 标题候选打分 → 粗层级（不依赖用户是否设置 Heading 样式）

给每个 `paragraph` 生成一个 **heading_score** 和 **initial_level**，**不信任任何单一信号**，而是融合：

* 样式线索：`style_name/style_id/outline_lvl_raw`（如果有）；
* 排版线索：`heading_features.font_max_size`、`is_bold`；
* 语义/格式线索：是否匹配“第X章/节/目录/目 录/（一）（二）/1、2、……”等**中文规范标题正则**；
* 黑名单：**“目 录/目录”**、大字号封面词（“政府采购/招标文件/(货物类)”）→ 直接判为**非结构**（或 level=0，不入树）。在你的样例里“目 录”“政府采购/招标文件（货物类）”都应被排除。

**规则优先级**（从强到弱）：

1. `style-outlineLvl` > 2) `paragraph-outlineLvl` > 3) 规范标题正则 > 4) 粗暴字号+粗体启发。
   **落盘**：为每个段落补个 `heading_candidate`（已有就复用），并记录 `score` 与 `initial_level`。

---

## Step 2. 章节栈建树（降噪、纠偏）

* 设定阈值：`heading_score >= 0.75` → 当作**章节标题**；`0.55~0.75` → **弱标题**（等下一步再确认）。
* 入栈策略：

    * 若新标题 `level` 大于当前栈顶 → **压栈**（成为子节点）。
    * 若小于等于 → **弹栈至父级**后作为兄弟节点插入。
* **纠偏**：遇到“第二册/第一册”这类“卷/册”标记，强制提升为 Level 1，并在其后**重置章节编号域**（避免错误嵌套）。你文件里“第一册 专用条款/第二册 通用条款”属于此类。

> 这一步只针对**高分标题**操作；弱标题先不入树，挂到一个“待决缓存”。

---

## Step 3. 表格挂载（父章节选择 + 伪嵌套识别）

**3.1 给表找父章节**
当遇到 `table`：把它挂到**最近的“已确认章节节点”**下（而不是最近一个段落）。例如 `t005` 挂到“评标信息”章节。


**3.2 真嵌套表**
如果你在解析层已经能递归拿到 `cell.nested_tables`，直接在树里把它们作为**表内子节点**挂在“父行/父单元格”下面（`node.type='table'` → `children`）。

**3.3 伪嵌套表（最佳实践：轻量启发式切块）**
对**单张表**内部执行“列名/列数/缩进风格”扫描，切出**子表片段**（synthetic nested tables），并落盘到父行的 `row.nested_tables[]`（`synthetic:true`；记录 `source_rows`、`confidence`）。你的 `t005` 里“技术部分(58)”后面出现“序号/评分因素/权重(%) /评分准则”的 4 列头，即可识别为一个伪子表块；“商务部分(6)”与“综合实力(1)”下面的 4 列块同理。

> 伪嵌套切块的具体做法我之前已给：**列名近似匹配 + 列数突变 + 缩进/编号 + 样式**多信号融合，阈值 0.75 起算，并输出 `header_signals:[{type:'syntheticHeaderMatch',…}]`。

---

## Step 4. 弱标题后判定（三步走，避免列表误判）

对 Step 1 里 `0.55~0.75` 的**弱标题**（如"（一）""1、"等），区分：
- **普通条款式列表**：（一）长句子 → （二）长句子（不升格）
- **小节型列表/章节标题**：（一）短标题 + 子内容（升格）

### 确认流程

#### **Step A：小节型列表判定（k ≥ 2）**
- 窗口内找出所有**同级编号项**（如 `（一）（二）（三）`）
- 检查每个编号项是否有子结构：
  - 紧随表格（TableBlock）
  - 更深缩进段落（ilvl > 当前）
  - 紧随子列表
- 统计 `k = 有子结构的编号项数`
- **k ≥ 2** → 继续 Step B，**k < 2** → 直接拒绝（打上 `plain-list` 信号）

#### **Step B：文本形态过滤**
- `isShortTitle`：移除编号后长度 ≤ 24 且不含句号（。；;!！？?）
- `hasColonTitle`：以"："或":"结尾
- 至少满足其一才有"标题形态"

#### **Step C：结构承载检测**
- 窗口内是否有表格（只有通过 Step A 后才检查）
- 首个后续块是否为长普通段落（> 40 字无编号）→ 减分

### 评分机制

```
基础分：0.40（小节型列表）
+ isShortTitle: +0.15
+ hasColonTitle: +0.10
+ hasTable: +0.20
- firstIsLongParagraph: -0.15
---
阈值：≥ 0.80 → 升格（score 改为 0.75）
```

### 验证关键词（搜索 JSON 输出）

```bash
# 核心判定信号
"plain-list"              # 被拒绝的普通列表
"item-with-table"         # 有表格的编号项
"item-with-deeper-indent" # 有深缩进的编号项
"short-title"             # 短标题
"colon-title"             # 冒号结尾
"final-score"             # 最终评分

# 查看结果
"score": 0.75             # 升级后的分数
```

**快速验证命令**：
```bash
# 被拒绝的列表
grep "plain-list" *_step4_*.json

# 升级成功的弱标题
grep "final-score.*0\.[89]" *_step4_*.json
```

> 这样避免了将"（一）营业执照"等条款误判为章节标题。

---

## Step 5. 极少量模型辅助（时间可控）

* **触发条件**：

    1. 某“弱标题”上下文冲突（规则指标相互打架），且它影响了**多个后续节点的父子关系**；
    2. 表格的**子表切块**得分在 0.65~0.75 の灰区，但下游强依赖结构。
* **做法**：把**非常短**的局部窗口（~600-1,000 字以内的纯文本/列头）丢给模型，问**二选一/三选一**判定（是不是标题？是不是子表头？），并**批量化**这类判定（把若干灰区一次问清）。
* **预算**：限定**最多 3-5 次**微调用，总时长 < 5-10 秒级（并行/流式都可）。

---

## Step 6. 目录页与封面去噪（强规则）

* 任意包含“目 录/目录/Contents”的段落区间，**整段标记为 `toc:true` 并从章节栈忽略**；
* 封面大字号 + 居中 + 少量文字（政府采购/招标文件/（年份）），**不入树**；
* 若某表格是“项目信息卡片”（两列表头“项目编号/项目名称/采购方式/评标方法”等），可挂到“项目信息/关键信息”一节，**但不作为章节**（`node.type='infocard'`）。你的 `t002` 属于此类。

---

## Step 7. 节点归一与编号（避免重复 c1/c2 歧义）

* **章节节点**：`node_id` 用**文档序号**（如 `sec-00045`）+ **规范化标题哈希**（防重）。
* **表节点**：直接用你已有的 `table_id`（`t001…t0xx`），**不要重命名**；子表用路径式：`t005.r006.t001`。
* **列 id**：各表**局部作用域**即可（每表 `c1..cN` 自己编号）。**发送给模型时**，如果需要跨表对齐，再在提示里讲清“每表独立列域，不要跨表套用列语义”。

---

## Step 8. 输出树的建议 Schema（保持原始中文，不翻译用户列名）

```json
{
  "doc": {
    "meta": { "filename": "...", "page_count": 92 },
    "root": {
      "type": "document",
      "children": [
        {
          "type": "section",
          "id": "sec-...-第一册-专用条款",
          "title": "第一册  专用条款",
          "level": 1,
          "children": [
            {
              "type": "section",
              "id": "sec-...-评标信息",
              "title": "评标信息",
              "level": 2,
              "children": [
                {
                  "type": "table",
                  "id": "t005",
                  "schema": { "...": "（保持 columns.label 原样）" },
                  "header_rows": [0],
                  "rows": [
                    {
                      "id": "r006",
                      "cells": [ ... ],
                      "nested_tables": [
                        {
                          "type": "table",
                          "id": "t005.r006.t001",
                          "synthetic": true,
                          "source_rows": [8, 11],
                          "schema": { "columns":[
                            {"id":"c1","label":"序号"},
                            {"id":"c2","label":"评分因素"},
                            {"id":"c3","label":"权重(%)"},
                            {"id":"c4","label":"评分准则"}
                          ]},
                          "rows": [ ... ],
                          "confidence": 0.78
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    }
  }
}
```

要点：**不翻译用户列名**；`key` 字段仅用于技术 id（如 `table_id/col_id`），不替换 `label` 的中文原文。

---

## Step 9. 性能策略（1 分钟内稳过）

* **单通道线性建树**：按文档顺序一次扫描、即产即挂，避免二次大重排；
* **轻量缓存**：把最近 3-5 个“已确认章节节点 id”缓存（命中父节点 O(1)）；
* **局部窗口判定**：弱标题与伪子表只看±8 行/段，阻止全表/全文统计；
* **模型微调用**：限频 + 批量，小窗口文本，优先 CPU 规则；
* **字符串操作**：用预编译正则（章节编号、中文括号序）；
* **I/O**：JSON streaming（边读边建树），大表行（如 `t011` 437 行）不进入模型，只做规整挂载。

---

## Step 10. 回填置信与可视化锚点（便于人工复核）

* 各节点记 `build_signals`（标题/子表判定来源）、`confidence`；
* 表与子表保留 `source_rows` 或 `source_block_ids`，用于前端高亮原文；
* 对被降级为“普通段落”的弱标题，标注 `demoted:true, reason:"low-score/no-following-structure"`，便于人工点修。

---

# 流程小抉择：先“高可信”再“微移动”

你的直觉是对的：**先归类高可信**（≥0.75 的标题、明确表头、明确章节标识）→ 挂表 → 切出伪子表；**剩余弱信号**再做**小范围移动**或**微调用模型**确认。这样既**快**又**稳**，且对“标题乱用”非常友好。

---

# 你现在就能落地的最小改动点

1. 在现有遍历里加入**“章节栈 + 标题分数/层级”**；
2. 表格挂载到最近**已确认章节**；
3. 对每个大表执行**列名/列数突变扫描**（±8 行窗口）→ 产出 `synthetic nested_tables`；
4. 输出树时**保留中文 label**与你已有的 `header_rows/header_signals`；
5. 灰区再做**批量小模型判定**（严格限量）。

这样你能把像 `t005` 的“技术部分 / 商务部分 / 综合实力”下的**子评分细则**，稳定地挂成**子表树**，同时把“目录/封面”等噪声排除在结构外。所有这些要素，在你给的 JSON 中都已有足够信号可用。

需要的话，我可以把上述“弱标题确认 + 伪子表切块”的**正则与打分权重**直接按你现有 `DocxStructureAnalyzer.java` 的风格给出伪代码版，便于你当天就植入。
